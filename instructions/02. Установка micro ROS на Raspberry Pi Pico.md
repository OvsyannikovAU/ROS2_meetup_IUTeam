Как было указано во вводной презентации хакатона, низкоуровневыми аппаратными средствами робота управляет плата микроконтроллера на прошивке microROS либо на самописной прошивке с корректно реализованным каналом связи.
В нашем случае это была плата микроконтроллера raspberry pi pico с прошивкой microROS.

Устанавливать microROS можно с любого компьютера, но удобнее из ОС Ubuntu; при этом необходимо заранее подготовить кабель usb-a - usb-mini для подключения rpi pico к компьютеру. Мы устанавливали microROS по [инструкции с GitHub'а microROS](https://github.com/micro-ROS/micro_ros_raspberrypi_pico_sdk). К сожалению, в ней были выявлены ошибки.
Так, на шаге 1 не хватает команды клонирования git'а самого microROS:

`git clone https://github.com/micro-ROS/micro_ros_raspberrypi_pico_sdk.git`

Итого код из шага 1 должен быть такой:
```
# Install dependencies
sudo apt install cmake g++ gcc-arm-none-eabi doxygen libnewlib-arm-none-eabi git python3
git clone --recurse-submodules https://github.com/raspberrypi/pico-sdk.git $HOME/pico-sdk
git clone https://github.com/micro-ROS/micro_ros_raspberrypi_pico_sdk.git $HOME/micro_ros_raspberrypi_pico_sdk

# Configure environment
echo "export PICO_SDK_PATH=$HOME/pico-sdk" >> ~/.bashrc
source ~/.bashrc
```

То есть, устанавливались два репозитория: pico-sdk для работы с микроконтроллером, и microROS для pi pico.
На шаге 2 немного меняем первую команду для перехода в верный каталог:

```
cd ~/micro_ros_raspberrypi_pico_sdk
mkdir build
cd build
cmake ..
make
```

На команде cmake  (предпоследней) появляется ворнинг с информацией об отсутствии picotool и рекомендацией установить его или прописать откуда его брать. На текущем этапе это не вызывает больших проблем, можно пропустить.

Второй шаг завершается загрузкой программы на микроконтроллер rpi pico. Новый МК сразу при подключении проводом переходит в режим ожидания прошивки - она определяется в системе как сменный USB-накопитель и на него можно закидывать файлы (последняя команда в шаге 2 инструкции как раз копирует файл .uf2 на нее). Если МК уже использовался ранее, то при подаче питания на него он сразу начинает выполнять прошивку. Для перевода его в режим ожидания прошивки перед подключением необходимо зажать кнопку Bootsel, подключить провод, дождаться появления в системе нового USB-накопителя и отпустить кнопку.

Сразу после копирования прошивки на USB-накопитель МК перезапускается и пытается ее выполнить. Если все корректно, то прошивка выполняется. Если в прошивке возникают ошибки, то МК сбрасывает прошивку и переходит в режим ее ожидания (с определением как USB-накопителя).

На шаге 3 устанавливаем micro-ROS agent - специальной программы для компьютера, которая будет поддерживать связь с микроконтроллером. Возможны два варианта. Мы пробовали установку через snap, но в итоге она не заработала. В репозитории [открыт вопрос об этом](ttps://github.com/micro-ROS/micro_ros_setup/issues/748), возможно, в будущем появится решение.
Второй способ установки microROS agent'а, через Docker, у нас заработал.

При установке через snap тоже были замечены неточности. Во время настройки необходимо сперва задать устройство, а уже потом порт. У нас были следующие команды:

```
snap set micro-ros-agent daemon=true
snap set micro-ros-agent device=/dev/ttyACM0
snap set micro-ros-agent discovery-port=serial
```

Переключение пакета code на канал --edge не произошел, так как пакет не был установлен. Мы его установили руками вот такой командой:
```
sudo snap install core --edge
```
После этого переключение не понадобилась.